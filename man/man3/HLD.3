.TH "HLD" 3 "Kyopro Library" \" -*- nroff -*-
.ad l
.nh
.SH NAME
HLD \- HL分解 \fB解説:https://hcpc-hokudai\&.github\&.io/archive/graph_tree_001\&.pdf\fP  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include 'hld\&.hpp'\fP
.SS "公開メンバ関数"

.in +1c
.ti -1c
.RI "\fBHLD\fP (int n)"
.br
.ti -1c
.RI "void \fBadd_edge\fP (int a, int b)"
.br
.ti -1c
.RI "void \fBbuild\fP (int root=0)"
.br
.ti -1c
.RI "\fBHLD\fP (const \fBVVI\fP &g, int root=0)"
.br
.ti -1c
.RI "vector< tuple< bool, int, int > > \fBpath\fP (int u, int v)"
.br
.RI "頂点 u, v を結ぶパスをHL分解後の辺の列にして返す "
.ti -1c
.RI "int \fBlca\fP (int u, int v)"
.br
.RI "頂点 u, v のLCAを返す "
.ti -1c
.RI "int \fBat\fP (int v)"
.br
.in -1c
.SH "詳解"
.PP 
HL分解 \fB解説:https://hcpc-hokudai\&.github\&.io/archive/graph_tree_001\&.pdf\fP 
.PP
 \fBhld\&.hpp\fP の \fB5\fP 行目に定義があります。
.SH "構築子と解体子"
.PP 
.SS "HLD::HLD (int n)\fR [inline]\fP"

.PP
 \fBhld\&.hpp\fP の \fB6\fP 行目に定義があります。
.SS "HLD::HLD (const \fBVVI\fP & g, int root = \fR0\fP)\fR [inline]\fP"

.PP
 \fBhld\&.hpp\fP の \fB9\fP 行目に定義があります。
.PP
参照先 \fBbuild()\fP\&.
.SH "関数詳解"
.PP 
.SS "void HLD::add_edge (int a, int b)\fR [inline]\fP"

.PP
 \fBhld\&.hpp\fP の \fB7\fP 行目に定義があります。
.SS "void HLD::build (int root = \fR0\fP)\fR [inline]\fP"

.PP
 \fBhld\&.hpp\fP の \fB8\fP 行目に定義があります。
.SS "vector< tuple< bool, int, int > > HLD::path (int u, int v)\fR [inline]\fP"

.PP
頂点 u, v を結ぶパスをHL分解後の辺の列にして返す \fR[f, l, r]\fP として、次を表す。
.IP "\(bu" 2
\fR[l, r]\fP: HL分解後の頂点列
.IP "\(bu" 2
\fRf = true\fP のとき、\fR[l, r]\fP はvからuへの向き
.IP "\(bu" 2
そうでないとき、逆向き 
.PP

.PP
 \fBhld\&.hpp\fP の \fB23\fP 行目に定義があります。
.SS "int HLD::lca (int u, int v)\fR [inline]\fP"

.PP
頂点 u, v のLCAを返す 
.PP
 \fBhld\&.hpp\fP の \fB40\fP 行目に定義があります。
.SS "int HLD::at (int v)\fR [inline]\fP"

.PP
 \fBhld\&.hpp\fP の \fB47\fP 行目に定義があります。

.SH "著者"
.PP 
 Kyopro Libraryのソースコードから抽出しました。
