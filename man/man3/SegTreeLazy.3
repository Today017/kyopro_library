.TH "SegTreeLazy< Monoid, Operator, mapping >" 3 "Kyopro Library" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SegTreeLazy< Monoid, Operator, mapping > \- 遅延評価セグメント木  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include 'segtree_lazy\&.hpp'\fP
.SS "公開型"

.in +1c
.ti -1c
.RI "using \fBMonoidType\fP = typename Monoid::Type"
.br
.ti -1c
.RI "using \fBOperatorType\fP = typename Operator::Type"
.br
.in -1c
.SS "公開メンバ関数"

.in +1c
.ti -1c
.RI "\fBSegTreeLazy\fP ()=default"
.br
.ti -1c
.RI "\fBSegTreeLazy\fP (int n)"
.br
.RI "要素数 n の遅延セグ木を構築する "
.ti -1c
.RI "\fBSegTreeLazy\fP (const vector< \fBMonoidType\fP > &v)"
.br
.RI "配列 v から遅延セグ木を構築する "
.ti -1c
.RI "void \fBset\fP (int i, \fBMonoidType\fP x)"
.br
.RI "i 番目の要素を x に更新する "
.ti -1c
.RI "void \fBapply\fP (int l, int r, \fBOperatorType\fP x)"
.br
.RI "区間 [l, r) に x を作用させる "
.ti -1c
.RI "\fBMonoidType\fP \fBfold\fP (int l, int r)"
.br
.RI "区間 [l, r) のモノイド積を返す "
.ti -1c
.RI "template<typename F> int \fBfind_right\fP (int l, F f)"
.br
.RI "区間 [l, x) のモノイド積が f を満たすような最大の x >= l を返す "
.ti -1c
.RI "template<typename F> int \fBfind_left\fP (int r, F f)"
.br
.RI "区間 [x, r) のモノイド積が f を満たすような最小の x<=r を返す "
.ti -1c
.RI "int \fBsize\fP ()"
.br
.ti -1c
.RI "\fBMonoidType\fP \fBoperator[]\fP (int i)"
.br
.in -1c
.SH "詳解"
.PP 

.SS "template<typename Monoid, typename Operator, auto mapping>
.br
struct SegTreeLazy< Monoid, Operator, mapping >"遅延評価セグメント木 


.PP
\fBテンプレート引数\fP
.RS 4
\fI\fBMonoid\fP\fP モノイド 
.br
\fI\fBOperator\fP\fP 作用素 
.br
\fImapping\fP （モノイドの元，作用素の元）→モノイドの元を返す関数 
.RE
.PP

.PP
 \fBsegtree_lazy\&.hpp\fP の \fB9\fP 行目に定義があります。
.SH "型定義メンバ詳解"
.PP 
.SS "template<typename Monoid, typename Operator, auto mapping> using \fBSegTreeLazy\fP< Monoid, Operator, mapping >::MonoidType = typename Monoid::Type"

.PP
 \fBsegtree_lazy\&.hpp\fP の \fB10\fP 行目に定義があります。
.SS "template<typename Monoid, typename Operator, auto mapping> using \fBSegTreeLazy\fP< Monoid, Operator, mapping >::OperatorType = typename Operator::Type"

.PP
 \fBsegtree_lazy\&.hpp\fP の \fB11\fP 行目に定義があります。
.SH "構築子と解体子"
.PP 
.SS "template<typename Monoid, typename Operator, auto mapping> \fBSegTreeLazy\fP< Monoid, Operator, mapping >\fB::SegTreeLazy\fP ()\fR [default]\fP"

.SS "template<typename Monoid, typename Operator, auto mapping> \fBSegTreeLazy\fP< Monoid, Operator, mapping >\fB::SegTreeLazy\fP (int n)\fR [inline]\fP"

.PP
要素数 n の遅延セグ木を構築する 
.PP
 \fBsegtree_lazy\&.hpp\fP の \fB15\fP 行目に定義があります。
.SS "template<typename Monoid, typename Operator, auto mapping> \fBSegTreeLazy\fP< Monoid, Operator, mapping >\fB::SegTreeLazy\fP (const vector< \fBMonoidType\fP > & v)\fR [inline]\fP"

.PP
配列 v から遅延セグ木を構築する 
.PP
 \fBsegtree_lazy\&.hpp\fP の \fB22\fP 行目に定義があります。
.SH "関数詳解"
.PP 
.SS "template<typename Monoid, typename Operator, auto mapping> void \fBSegTreeLazy\fP< Monoid, Operator, mapping >::set (int i, \fBMonoidType\fP x)\fR [inline]\fP"

.PP
i 番目の要素を x に更新する 
.PP
 \fBsegtree_lazy\&.hpp\fP の \fB31\fP 行目に定義があります。
.SS "template<typename Monoid, typename Operator, auto mapping> void \fBSegTreeLazy\fP< Monoid, Operator, mapping >::apply (int l, int r, \fBOperatorType\fP x)\fR [inline]\fP"

.PP
区間 [l, r) に x を作用させる 
.PP
 \fBsegtree_lazy\&.hpp\fP の \fB40\fP 行目に定義があります。
.SS "template<typename Monoid, typename Operator, auto mapping> \fBMonoidType\fP \fBSegTreeLazy\fP< Monoid, Operator, mapping >::fold (int l, int r)\fR [inline]\fP"

.PP
区間 [l, r) のモノイド積を返す 
.PP
 \fBsegtree_lazy\&.hpp\fP の \fB62\fP 行目に定義があります。
.SS "template<typename Monoid, typename Operator, auto mapping> template<typename F> int \fBSegTreeLazy\fP< Monoid, Operator, mapping >::find_right (int l, F f)\fR [inline]\fP"

.PP
区間 [l, x) のモノイド積が f を満たすような最大の x >= l を返す 
.PP
\fB注意\fP
.RS 4
\fRf(Monoid::id())=true\fP が成り立つ必要がある 
.RE
.PP
\fB覚え書き\fP
.RS 4
O(log(N)) 
.RE
.PP

.PP
 \fBsegtree_lazy\&.hpp\fP の \fB80\fP 行目に定義があります。
.SS "template<typename Monoid, typename Operator, auto mapping> template<typename F> int \fBSegTreeLazy\fP< Monoid, Operator, mapping >::find_left (int r, F f)\fR [inline]\fP"

.PP
区間 [x, r) のモノイド積が f を満たすような最小の x<=r を返す 
.PP
\fB注意\fP
.RS 4
\fRf(Monoid::id())=true\fP が成り立つ必要がある 
.RE
.PP
\fB覚え書き\fP
.RS 4
O(log(N)) 
.RE
.PP

.PP
 \fBsegtree_lazy\&.hpp\fP の \fB119\fP 行目に定義があります。
.SS "template<typename Monoid, typename Operator, auto mapping> int \fBSegTreeLazy\fP< Monoid, Operator, mapping >::size ()\fR [inline]\fP"

.PP
 \fBsegtree_lazy\&.hpp\fP の \fB154\fP 行目に定義があります。
.SS "template<typename Monoid, typename Operator, auto mapping> \fBMonoidType\fP \fBSegTreeLazy\fP< Monoid, Operator, mapping >::operator[] (int i)\fR [inline]\fP"

.PP
 \fBsegtree_lazy\&.hpp\fP の \fB155\fP 行目に定義があります。

.SH "著者"
.PP 
 Kyopro Libraryのソースコードから抽出しました。
